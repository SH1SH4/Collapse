Index: cam.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport os\r\nimport sys\r\nimport pytmx\r\nimport pyscroll\r\nfrom pytmx.util_pygame import load_pygame\r\npygame.init()\r\n\r\npygame.display.set_caption(\"Start\")\r\nsize = width, height = 1920, 1020\r\nscreen = pygame.display.set_mode(size)\r\n\r\ncolor = \"white\"\r\n\r\ntmx_data = load_pygame(\"maps/poligon2.0.tmx\")\r\nmap_data = pyscroll.TiledMapData(tmx_data)\r\nscreen_size = (1920, 1020)\r\nmap_layer = pyscroll.BufferedRenderer(map_data, screen_size, True)\r\ngroup = pyscroll.PyscrollGroup(map_layer=map_layer)\r\nobstacles = pygame.sprite.Group()\r\nhero = pygame.sprite.Group()\r\n\r\n\r\nclass Map:\r\n    def __init__(self, filename, free_tile):\r\n        self.map = pytmx.load_pygame(f\"maps/{filename}\")\r\n        self.height = self.map.height\r\n        self.width = self.map.width\r\n        self.tile_size = self.map.tilewidth\r\n        self.free_tile = free_tile\r\n\r\n    def render(self):\r\n        for y in range(self.height):\r\n            for x in range(self.width):\r\n                if self.map.tiledgidmap[self.map.get_tile_gid(x, y, 0)] not in self.free_tile:\r\n                    Obstacles(self.map.get_tile_image(x, y, 0), x * self.tile_size, y * self.tile_size)\r\n\r\n    def get_tile_id(self, position):\r\n        return self.map.tiledgidmap[self.map.get_tile_gid(*position, 0)]\r\n\r\n    def is_free(self, position):\r\n        return self.get_tile_id(position) not in self.free_tile\r\n\r\n\r\nclass Obstacles(pygame.sprite.Sprite):\r\n    def __init__(self, img, x, y):\r\n        super().__init__(obstacles)\r\n        self.image = img\r\n        self.rect = self.image.get_rect()\r\n        self.rect.x, self.rect.y = x, y\r\n        # self.add(obstacles)\r\n        self.mask = pygame.mask.from_surface(self.image)\r\n\r\n\r\nclass Button:\r\n    def __init__(self, width, height, inactive=None, active=None):\r\n        self.width = width\r\n        self.height = height\r\n        self.inactive = pygame.image.load(inactive)\r\n        self.active = pygame.image.load(active)\r\n\r\n    def draw(self, x, y, name, action=None):\r\n        mouse = pygame.mouse.get_pos()\r\n        click = pygame.mouse.get_pressed()\r\n        if x < mouse[0] < x + self.width and y < mouse[1] < y + self.height:\r\n            screen.blit(self.active, (x, y))\r\n            if click[0] == 1:\r\n                screen.blit(self.active, (x, y))\r\n                if name == \"play\":\r\n                    start_game()\r\n                    print(\"Ok\")\r\n                if name == \"new_game\":\r\n                    print(\"New game\")\r\n                if name == \"exit\":\r\n                    pygame.quit()\r\n                    quit()\r\n        else:\r\n            screen.blit(self.inactive, (x, y))\r\n\r\n\r\nclass Hero(pygame.sprite.Sprite):\r\n    def __init__(self, position, sheet, columns, rows, x, y):\r\n        pygame.sprite.Sprite.__init__(self, group)\r\n\r\n        self.frames = []\r\n        self.cut_sheet(sheet, columns, rows)\r\n        self.cur_frame = 0\r\n        self.image = self.frames[self.cur_frame]\r\n        self.rect.x, self.rect.y = position\r\n        self.delay = 0\r\n        self.add(hero)\r\n\r\n    def cut_sheet(self, sheet, columns, rows):\r\n        self.rect = pygame.Rect(0, 0, sheet.get_width() // columns, sheet.get_height() // rows)\r\n        for j in range(rows):\r\n            for i in range(columns):\r\n                frame_location = (self.rect.w * i, self.rect.h * j)\r\n                self.frames.append(sheet.subsurface(pygame.Rect(frame_location, self.rect.size)))\r\n\r\n    def animation(self):\r\n        if self.delay % 5 == 0:\r\n            self.cur_frame = (self.cur_frame + 1) % len(self.frames)\r\n            self.image = self.frames[self.cur_frame]\r\n        self.delay += 1\r\n\r\n    def update(self, world, delta_time):\r\n        key = pygame.key.get_pressed()\r\n        if key[pygame.K_LEFT]:\r\n            self.rect.x -= 5\r\n            self.animation()\r\n            if pygame.sprite.spritecollideany(self, obstacles):\r\n                self.rect.x += 5\r\n        if key[pygame.K_RIGHT]:\r\n            self.rect.x += 5\r\n            self.animation()\r\n            if pygame.sprite.spritecollideany(self, obstacles):\r\n                self.rect.x -= 5\r\n        if key[pygame.K_UP]:\r\n            self.rect.y -= 5\r\n            self.animation()\r\n            if pygame.sprite.spritecollideany(self, obstacles):\r\n                self.rect.y += 5\r\n        if key[pygame.K_DOWN]:\r\n            self.rect.y += 5\r\n            self.animation()\r\n            if pygame.sprite.spritecollideany(self, obstacles):\r\n                self.rect.y -= 5\r\n\r\n\r\ndef load_image(name, colorkey=None):\r\n    fullname = os.path.join('data', name)\r\n    if not os.path.isfile(fullname):\r\n        print(f\"Файл с изображением '{fullname}' не найден\")\r\n        sys.exit()\r\n    image = pygame.image.load(fullname)\r\n    return image\r\n\r\n\r\ndef play_but():\r\n    play = Button(400, 100, \"data/play_inactive.png\", \"data/play_active.png\")\r\n    play.draw(760, 400, \"play\")\r\n\r\n\r\ndef newgame_but():\r\n    new_game = Button(400, 100, \"data/test_inacrive.png\", \"data/test_acrive_black.png\")\r\n    new_game.draw(760, 550, \"new_game\")\r\n\r\n\r\ndef exit_but():\r\n    exit_b = Button(400, 100, \"data/exit_inacrive.png\", \"data/exit_acrive.png\")\r\n    exit_b.draw(760, 700, \"exit\")\r\n\r\n\r\ndef start_screen():\r\n    menu_background = pygame.image.load(\"data/background.png\")\r\n    screen.blit(menu_background, (0, 0))\r\n    clock = pygame.time.Clock()\r\n    run = True\r\n    while run:\r\n        for event in pygame.event.get():\r\n            play_but()\r\n            newgame_but()\r\n            exit_but()\r\n            if event.type == pygame.QUIT:\r\n                run = False\r\n                pygame.quit()\r\n                quit()\r\n        pygame.display.update()\r\n\r\n\r\ndef start_game():\r\n    running = True\r\n    screen.fill((0, 0, 0))\r\n    world = Map(\"poligon2.0.tmx\", [30, 15])\r\n    hero = Hero((50, 50), load_image(\"llama (1).png\"), 3, 2, 50, 50)\r\n    # game = Game(world, hero)\r\n    world.render()\r\n    clock = pygame.time.Clock()\r\n    fps = 60\r\n    clock = pygame.time.Clock()\r\n    while running:\r\n        delta_time = clock.tick(fps) / 1000\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n        obstacles.update()\r\n        group.update(world, delta_time)\r\n        group.center(hero.rect.center)\r\n        group.draw(screen)\r\n        pygame.display.flip()\r\n\r\n    pygame.quit()\r\n\r\nstart_screen()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- cam.py	(revision ebb712107e4b96770362ed6ad57091ce715bbd0b)
+++ cam.py	(date 1610468473607)
@@ -1,6 +1,7 @@
 import pygame
 import os
 import sys
+from random import randint
 import pytmx
 import pyscroll
 from pytmx.util_pygame import load_pygame
@@ -18,6 +19,7 @@
 map_layer = pyscroll.BufferedRenderer(map_data, screen_size, True)
 group = pyscroll.PyscrollGroup(map_layer=map_layer)
 obstacles = pygame.sprite.Group()
+enemy = pygame.sprite.Group()
 hero = pygame.sprite.Group()
 
 
@@ -29,11 +31,37 @@
         self.tile_size = self.map.tilewidth
         self.free_tile = free_tile
 
+    def find_path(self, start, target):
+        INF = 1000
+        x, y = start
+        distance = [[INF] * self.width for _ in range(self.height)]
+        distance[y][x] = 0
+        prev = [[None] * self.width for _ in range(self.height)]
+        queue = [(x, y)]
+        while queue:
+            x. y = queue.pop(0)
+            for dx, dy in (1, 0), (0, 1), (-1, 0), (0, -1):
+                next_x, next_y = x + dx, x + dy
+                if 0 <= next_x < self.width and 0 < next_y < self.height and self.is_free((next_x, next_y)) and distance[next_y][next_x] == INF:
+                    distance[next_y][next_x] = distance[y][x] + 1
+                    prev[next_y][next_x] = (x, y)
+                    queue.append(next_x, next_y)
+        x, y = target
+        if distance[y][x] == INF or start == target:
+            return start
+        while prev[y][x] != start:
+            x, y = prev[y][x]
+        return x, y
+
     def render(self):
         for y in range(self.height):
             for x in range(self.width):
                 if self.map.tiledgidmap[self.map.get_tile_gid(x, y, 0)] not in self.free_tile:
                     Obstacles(self.map.get_tile_image(x, y, 0), x * self.tile_size, y * self.tile_size)
+        for i in range(100):
+            x, y = (randint(0, self.width - 1), randint(0, self.height - 1))
+            if self.map.tiledgidmap[self.map.get_tile_gid(x, y, 0)] in self.free_tile:
+                Enemy((x * self.tile_size, y * self.tile_size), load_image("llama (1).png"), 3, 2)
 
     def get_tile_id(self, position):
         return self.map.tiledgidmap[self.map.get_tile_gid(*position, 0)]
@@ -79,17 +107,20 @@
 
 
 class Hero(pygame.sprite.Sprite):
-    def __init__(self, position, sheet, columns, rows, x, y):
+    def __init__(self, position, sheet, columns, rows):
         pygame.sprite.Sprite.__init__(self, group)
-
         self.frames = []
         self.cut_sheet(sheet, columns, rows)
         self.cur_frame = 0
         self.image = self.frames[self.cur_frame]
         self.rect.x, self.rect.y = position
         self.delay = 0
+        self.speed = 20
         self.add(hero)
 
+    def get_position(self):
+        return self.rect.x, self.rect.y
+
     def cut_sheet(self, sheet, columns, rows):
         self.rect = pygame.Rect(0, 0, sheet.get_width() // columns, sheet.get_height() // rows)
         for j in range(rows):
@@ -106,25 +137,51 @@
     def update(self, world, delta_time):
         key = pygame.key.get_pressed()
         if key[pygame.K_LEFT]:
-            self.rect.x -= 5
+            self.rect.x -= self.speed
             self.animation()
             if pygame.sprite.spritecollideany(self, obstacles):
-                self.rect.x += 5
+                self.rect.x += self.speed
         if key[pygame.K_RIGHT]:
-            self.rect.x += 5
+            self.rect.x += self.speed
             self.animation()
             if pygame.sprite.spritecollideany(self, obstacles):
-                self.rect.x -= 5
+                self.rect.x -= self.speed
         if key[pygame.K_UP]:
-            self.rect.y -= 5
+            self.rect.y -= self.speed
             self.animation()
             if pygame.sprite.spritecollideany(self, obstacles):
-                self.rect.y += 5
+                self.rect.y += self.speed
         if key[pygame.K_DOWN]:
-            self.rect.y += 5
+            self.rect.y += self.speed
             self.animation()
             if pygame.sprite.spritecollideany(self, obstacles):
-                self.rect.y -= 5
+                self.rect.y -= self.speed
+
+
+class Enemy(pygame.sprite.Sprite):
+    def __init__(self, position, sheet, columns, rows):
+        pygame.sprite.Sprite.__init__(self, group)
+        self.frames = []
+        self.cut_sheet(sheet, columns, rows)
+        self.cur_frame = 0
+        self.image = self.frames[self.cur_frame]
+        self.rect.x, self.rect.y = position
+        self.delay = 0
+        self.add(enemy)
+
+    def get_position(self):
+        return self.rect.x, self.rect.y
+
+    def update(self, world, delta_time):
+        next_position = world.find_path((self.rect.x, self.rect.y), hero.get_position)
+        self.rect.x, self.rect.y = next_position
+
+    def cut_sheet(self, sheet, columns, rows):
+        self.rect = pygame.Rect(0, 0, sheet.get_width() // columns, sheet.get_height() // rows)
+        for j in range(rows):
+            for i in range(columns):
+                frame_location = (self.rect.w * i, self.rect.h * j)
+                self.frames.append(sheet.subsurface(pygame.Rect(frame_location, self.rect.size)))
 
 
 def load_image(name, colorkey=None):
@@ -188,7 +245,7 @@
         group.center(hero.rect.center)
         group.draw(screen)
         pygame.display.flip()
-
     pygame.quit()
 
-start_screen()
\ No newline at end of file
+
+start_screen()
Index: .idea/CovidInRussia.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\r\n    </content>\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.7\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/CovidInRussia.iml	(revision ebb712107e4b96770362ed6ad57091ce715bbd0b)
+++ .idea/CovidInRussia.iml	(date 1610468346981)
@@ -4,7 +4,7 @@
     <content url="file://$MODULE_DIR$">
       <excludeFolder url="file://$MODULE_DIR$/venv" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.7" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.8 (Collapse)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
